<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Math Art Interactive Canvas</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            z-index: 10;
            mix-blend-mode: difference;
        }

        #hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.3);
            font-size: 1.5rem;
            pointer-events: none;
            transition: opacity 0.5s;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="ui-layer">Egyptian Orchestra // V6.0</div>
    <div id="hint">Tap for Ney & Strings</div>
    <canvas id="canvas"></canvas>

    <script>
        /**
         * MASTERPIECE SYNTHESIZER
         * * A generative art toy blending math with styles of Van Gogh, Picasso, Da Vinci, and Michelangelo.
         * * Audio: Egyptian/Middle Eastern Scales.
         * * Instruments: Ney (Flute) and Violent Strings.
         * * Wrapped in IIFE to prevent scope pollution.
         */

        (function() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const hint = document.getElementById('hint');

            let width, height;
            let entities = [];

            // --- AUDIO SYSTEM (EGYPTIAN ORCHESTRA) ---
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            let audioCtx;

            // Frequency Map
            const NOTE_FREQS = {
                C3: 130.81, Cs3: 138.59, D3: 146.83, Eb3: 155.56, E3: 164.81, F3: 174.61, Fs3: 185.00, G3: 196.00, Gs3: 207.65, A3: 220.00, Bb3: 233.08, B3: 246.94,
                C4: 261.63, Cs4: 277.18, D4: 293.66, Eb4: 311.13, E4: 329.63, F4: 349.23, Fs4: 369.99, G4: 392.00, Gs4: 415.30, A4: 440.00, Bb4: 466.16, B4: 493.88,
                C5: 523.25, Cs5: 554.37, D5: 587.33, Eb5: 622.25, E5: 659.25, F5: 698.46, Fs5: 739.99, G5: 783.99, Gs5: 830.61, A5: 880.00, Bb5: 932.33, B5: 987.77
            };

            // Egyptian / Middle Eastern Melodies
            const MELODIES = {
                // Picasso -> Aggressive Strings (E Phrygian Dominant)
                picasso: [NOTE_FREQS.E3, NOTE_FREQS.F3, NOTE_FREQS.E3, NOTE_FREQS.Gs3, NOTE_FREQS.A3, NOTE_FREQS.B3, NOTE_FREQS.A3, NOTE_FREQS.F3],
                
                // Michelangelo -> High Strings (Double Harmonic Major)
                michelangelo: [NOTE_FREQS.E5, NOTE_FREQS.F5, NOTE_FREQS.Gs5, NOTE_FREQS.A5, NOTE_FREQS.B5, NOTE_FREQS.C5, NOTE_FREQS.B5, NOTE_FREQS.A5],
                
                // Van Gogh -> The Ney (D Phrygian Dominant)
                vangogh: [NOTE_FREQS.D4, NOTE_FREQS.Eb4, NOTE_FREQS.Fs4, NOTE_FREQS.G4, NOTE_FREQS.A4, NOTE_FREQS.Bb4, NOTE_FREQS.A4, NOTE_FREQS.G4, NOTE_FREQS.Fs4, NOTE_FREQS.Eb4], 
                
                // Da Vinci -> Oud Plucks
                davinci: [NOTE_FREQS.A4, NOTE_FREQS.Bb4, NOTE_FREQS.Cs5, NOTE_FREQS.D5, NOTE_FREQS.Cs5, NOTE_FREQS.Bb4, NOTE_FREQS.A4, NOTE_FREQS.G4, NOTE_FREQS.F4, NOTE_FREQS.E4] 
            };

            let melodyIndices = { picasso: 0, michelangelo: 0, vangogh: 0, davinci: 0 };

            function initAudio() {
                if (!audioCtx) audioCtx = new AudioContext();
                if (audioCtx.state === 'suspended') audioCtx.resume();
            }

            function playSound(style) {
                if (!audioCtx) return;

                const osc = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();

                const melody = MELODIES[style] || MELODIES.vangogh;
                const noteIndex = melodyIndices[style] % melody.length;
                const noteFreq = melody[noteIndex] || 440.00;
                
                melodyIndices[style]++;

                // --- INSTRUMENT DESIGN ---
                if (style === 'picasso') {
                    // "Violent" Instruments (Violins/Cellos)
                    // Sharp Sawtooth wave with fast attack
                    osc.type = 'sawtooth';
                    gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.25, audioCtx.currentTime + 0.05); // Aggressive attack
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 3.0); 
                } else if (style === 'vangogh') {
                    // The Ney (Flute)
                    // Triangle wave is softer than saw, richer than sine.
                    // Slow, breathy attack.
                    osc.type = 'triangle'; 
                    gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.3); // Slow breath attack
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 4.0); // Long wind decay
                } else if (style === 'davinci') {
                    // Oud (Plucked String)
                    osc.type = 'sawtooth'; // Sawtooth filtered (simulated by low gain)
                    gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + 0.02); // Pluck
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 2.0); 
                } else {
                    // Michelangelo - Ethereal Strings
                    osc.type = 'sine';
                    gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.2, audioCtx.currentTime + 0.5); 
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 6.0); 
                }

                if (Number.isFinite(noteFreq)) {
                    osc.frequency.setValueAtTime(noteFreq, audioCtx.currentTime);
                } else {
                    osc.frequency.setValueAtTime(440, audioCtx.currentTime);
                }
                
                osc.connect(gainNode);
                gainNode.connect(audioCtx.destination);

                osc.start();
                osc.stop(audioCtx.currentTime + 6.0);
            }

            // --- ARTISTIC STYLES ---

            const ARTIST_STYLES = {
                vangogh: { name: 'Van Gogh', hueBase: 210, secHue: 50 }, 
                picasso: { name: 'Picasso', hueBase: 0, range: 360 }, 
                davinci: { name: 'Da Vinci', hueBase: 35, sat: 40, light: 60 },
                michelangelo: { name: 'Michelangelo', hueBase: 200, secHue: 25 }
            };

            class Entity {
                constructor(x, y, style) {
                    this.x = x;
                    this.y = y;
                    this.style = style;
                    this.life = 1.0;
                    this.decay = 0.002 + Math.random() * 0.003; 
                }
                
                update() {
                    this.life -= this.decay;
                    return this.life > 0;
                }

                draw(ctx) {}
            }

            // 1. VAN GOGH: STARRY SWIRLS
            class VanGoghSwirl extends Entity {
                constructor(x, y) {
                    super(x, y, 'vangogh');
                    this.particles = [];
                    const count = 50;
                    for(let i=0; i<count; i++) {
                        this.particles.push({
                            angle: Math.random() * Math.PI * 2,
                            r: Math.random() * 10,
                            speed: 0.5 + Math.random() * 1.5,
                            length: 5 + Math.random() * 15,
                            width: 2 + Math.random() * 3,
                            isStar: Math.random() > 0.8 
                        });
                    }
                }

                draw(ctx) {
                    const config = ARTIST_STYLES.vangogh;
                    for(let p of this.particles) {
                        p.angle += 0.05 * p.speed;
                        p.r += 0.5 * p.speed;
                        let currX = this.x + Math.cos(p.angle) * p.r * 5 * (1.1 - this.life);
                        let currY = this.y + Math.sin(p.angle) * p.r * 5 * (1.1 - this.life);
                        let h = p.isStar ? config.secHue + Math.random()*20 : config.hueBase + Math.random()*30;
                        let l = p.isStar ? 70 : 40;
                        ctx.strokeStyle = `hsla(${h}, 80%, ${l}%, ${this.life})`;
                        ctx.lineWidth = p.width;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        let strokeAngle = p.angle + Math.PI/2;
                        let dx = Math.cos(strokeAngle) * p.length;
                        let dy = Math.sin(strokeAngle) * p.length;
                        ctx.moveTo(currX - dx/2, currY - dy/2);
                        ctx.lineTo(currX + dx/2, currY + dy/2);
                        ctx.stroke();
                    }
                }
            }

            // 2. DA VINCI: VITRUVIAN MECHANISM
            class DaVinciSketch extends Entity {
                constructor(x, y) {
                    super(x, y, 'davinci');
                    this.a = 1 + Math.floor(Math.random() * 3);
                    this.b = 1 + Math.floor(Math.random() * 3);
                    this.delta = Math.PI / 2;
                    this.scale = 80 + Math.random() * 50;
                    this.phase = 0;
                }

                draw(ctx) {
                    const config = ARTIST_STYLES.davinci;
                    const time = (1.0 - this.life) * 10;
                    ctx.strokeStyle = `hsla(${config.hueBase}, ${config.sat}%, ${config.light}%, ${this.life})`;
                    ctx.lineWidth = 0.8; 
                    ctx.beginPath();
                    for (let i = 0; i < 100; i++) {
                        let t = time + (i * 0.02);
                        let x = this.x + Math.sin(this.a * t + this.delta) * this.scale;
                        let y = this.y + Math.sin(this.b * t) * this.scale;
                        x += (Math.random() - 0.5) * 2;
                        y += (Math.random() - 0.5) * 2;
                        if (i===0) ctx.moveTo(x, y);
                        else ctx.lineTo(x, y);
                    }
                    ctx.stroke();
                    if (this.life > 0.5) {
                        ctx.strokeStyle = `hsla(${config.hueBase}, ${config.sat}%, ${config.light}%, ${this.life * 0.3})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.scale, 0, Math.PI*2);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.scale * 0.618, 0, Math.PI*2); 
                        ctx.stroke();
                    }
                }
            }

            // 3. PICASSO: CUBIST FRAGMENTS
            class PicassoFragment extends Entity {
                constructor(x, y) {
                    super(x, y, 'picasso');
                    this.shapes = [];
                    const count = 5 + Math.floor(Math.random() * 5);
                    for(let i=0; i<count; i++) {
                        this.shapes.push({
                            sides: 3 + Math.floor(Math.random() * 2), 
                            angle: Math.random() * Math.PI,
                            size: 20 + Math.random() * 60,
                            dx: (Math.random() - 0.5) * 2,
                            dy: (Math.random() - 0.5) * 2,
                            hue: Math.random() * 360, 
                            sat: 60 + Math.random() * 40
                        });
                    }
                }

                draw(ctx) {
                    for(let s of this.shapes) {
                        s.angle += 0.01;
                        let cx = this.x + s.dx * (1-this.life) * 100; 
                        let cy = this.y + s.dy * (1-this.life) * 100;
                        ctx.fillStyle = `hsla(${s.hue}, ${s.sat}%, 50%, ${this.life * 0.6})`;
                        ctx.strokeStyle = `hsla(${s.hue}, ${s.sat}%, 80%, ${this.life})`;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        for(let i=0; i<=s.sides; i++) {
                            let a = s.angle + (i * 2 * Math.PI / s.sides);
                            let px = cx + s.size * Math.cos(a);
                            let py = cy + s.size * Math.sin(a);
                            if(i===0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    }
                }
            }

            // 4. MICHELANGELO: FRESCO SPARK
            class MichelangeloSpark extends Entity {
                constructor(x, y) {
                    super(x, y, 'michelangelo');
                    this.nodes = [];
                    for(let i=0; i<8; i++) {
                        this.nodes.push({
                            ox: (Math.random() - 0.5) * 150,
                            oy: (Math.random() - 0.5) * 150,
                            colorType: Math.random() > 0.5 ? 'sky' : 'earth'
                        });
                    }
                }

                draw(ctx) {
                    const config = ARTIST_STYLES.michelangelo;
                    ctx.lineWidth = 4 * this.life;
                    for(let i=0; i<this.nodes.length; i++) {
                        let n = this.nodes[i];
                        n.ox *= 1.005; 
                        n.oy *= 1.005;
                        let px = this.x + n.ox;
                        let py = this.y + n.oy;
                        let hue = n.colorType === 'sky' ? config.hueBase : config.secHue;
                        let sat = 40;
                        let light = 60 + Math.random() * 20;
                        let grad = ctx.createRadialGradient(px, py, 0, px, py, 40);
                        grad.addColorStop(0, `hsla(${hue}, ${sat}%, ${light}%, ${this.life})`);
                        grad.addColorStop(1, `hsla(${hue}, ${sat}%, ${light}%, 0)`);
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.arc(px, py, 40, 0, Math.PI*2);
                        ctx.fill();
                        ctx.strokeStyle = `hsla(${hue}, ${sat}%, 80%, ${this.life * 0.4})`;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.quadraticCurveTo(this.x, py, px, py);
                        ctx.stroke();
                    }
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = 'white';
                    ctx.fillStyle = `rgba(255, 255, 255, ${this.life})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, 3, 0, Math.PI*2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }

            // --- CORE LOOP ---

            function resize() {
                width = canvas.width = window.innerWidth;
                height = canvas.height = window.innerHeight;
            }

            function createRandomEffect(x, y) {
                const rand = Math.random();
                let effect;
                let style = '';

                if (rand < 0.25) {
                    effect = new VanGoghSwirl(x, y);
                    style = 'vangogh';
                } else if (rand < 0.50) {
                    effect = new PicassoFragment(x, y);
                    style = 'picasso';
                } else if (rand < 0.75) {
                    effect = new DaVinciSketch(x, y);
                    style = 'davinci';
                } else {
                    effect = new MichelangeloSpark(x, y);
                    style = 'michelangelo';
                }

                initAudio();
                playSound(style);
                entities.push(effect);
            }

            function animate() {
                ctx.fillStyle = 'rgba(5, 5, 5, 0.2)'; 
                ctx.fillRect(0, 0, width, height);

                ctx.globalCompositeOperation = 'source-over'; 

                for (let i = entities.length - 1; i >= 0; i--) {
                    const ent = entities[i];
                    if (ent.style === 'vangogh') ctx.globalCompositeOperation = 'screen'; 
                    else if (ent.style === 'michelangelo') ctx.globalCompositeOperation = 'lighter';
                    else ctx.globalCompositeOperation = 'source-over';

                    if (ent.update()) {
                        ent.draw(ctx);
                    } else {
                        entities.splice(i, 1);
                    }
                }
                ctx.globalCompositeOperation = 'source-over';
                requestAnimationFrame(animate);
            }

            // --- INTERACTION ---

            window.addEventListener('resize', resize);
            
            function handleInput(e) {
                e.preventDefault();
                if(hint) hint.style.opacity = '0';
                
                if(e.changedTouches) {
                    for(let i=0; i<e.changedTouches.length; i++) {
                        createRandomEffect(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                    }
                } else {
                    createRandomEffect(e.clientX, e.clientY);
                }
            }

            window.addEventListener('mousedown', handleInput);
            window.addEventListener('touchstart', handleInput, {passive: false});

            resize();
            animate();
        })();
    </script>
</body>
</html>