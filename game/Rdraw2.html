<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Math Art Interactive Canvas</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        canvas {
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            color: rgba(255, 255, 255, 0.5);
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            z-index: 10;
            mix-blend-mode: difference;
        }

        #hint {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgba(255, 255, 255, 0.3);
            font-size: 1.5rem;
            pointer-events: none;
            transition: opacity 0.5s;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="ui-layer">Abstract Nature Canvas // V2.0</div>
    <div id="hint">Tap to paint</div>
    <canvas id="canvas"></canvas>

    <script>
        /**
         * MATH ART SYNTHESIZER
         * * A generative art toy that combines mathematical patterns with procedural audio.
         */

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const hint = document.getElementById('hint');

        let width, height;
        let entities = [];
        let hueCycle = 0;

        // --- AUDIO SYSTEM ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;

        // Pentatonic Scale (C Major Pentatonic) frequencies for pleasant random notes
        const SCALE = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25, 783.99, 880.00];

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function playSound() {
            if (!audioCtx) return;

            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            // Randomize sound properties based on "math" theme
            const note = SCALE[Math.floor(Math.random() * SCALE.length)];
            // Add slight detune for chorus effect
            const detune = (Math.random() - 0.5) * 10; 
            
            osc.type = Math.random() > 0.5 ? 'sine' : 'triangle';
            osc.frequency.setValueAtTime(note, audioCtx.currentTime);
            osc.detune.setValueAtTime(detune, audioCtx.currentTime);

            // Envelope (Attack -> Decay)
            gainNode.gain.setValueAtTime(0, audioCtx.currentTime);
            gainNode.gain.linearRampToValueAtTime(0.3, audioCtx.currentTime + 0.05); // Attack
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 1.5); // Decay

            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            osc.start();
            osc.stop(audioCtx.currentTime + 1.5);
        }

        // --- MATH VISUALS ---

        function getNaturalColor(hue, alpha) {
            // More natural saturation/lightness variance
            const s = 60 + Math.random() * 20; // 60-80%
            const l = 40 + Math.random() * 30; // 40-70%
            return `hsla(${hue}, ${s}%, ${l}%, ${alpha})`;
        }

        class Entity {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.life = 1.0;
                this.decay = 0.003 + Math.random() * 0.005; // Slower decay for painting feel
                this.colorHue = (hueCycle + Math.random() * 40) % 360;
            }
            
            update() {
                this.life -= this.decay;
                return this.life > 0;
            }

            draw(ctx) {}
        }

        // 1. FLORAL IMPRESSIONISM (Phyllotaxis / Logarithmic Spirals)
        class SpiralBurst extends Entity {
            constructor(x, y) {
                super(x, y);
                this.particles = [];
                const count = 40 + Math.random() * 30;
                for(let i=0; i<count; i++) {
                    this.particles.push({
                        angle: Math.random() * Math.PI * 2,
                        speed: 0.5 + Math.random() * 2,
                        size: 2 + Math.random() * 8,
                        wobble: Math.random() * Math.PI,
                        spiralFactor: (Math.random() > 0.5 ? 1 : -1) * (0.02 + Math.random() * 0.05)
                    });
                }
            }

            draw(ctx) {
                for(let p of this.particles) {
                    // Polar to Cartesian with rotation
                    p.angle += p.spiralFactor;
                    let currDist = (1.0 - this.life) * 150 * p.speed; 
                    
                    let px = this.x + Math.cos(p.angle) * currDist;
                    let py = this.y + Math.sin(p.angle) * currDist;

                    // Painterly touch: Rotation and varying size
                    ctx.fillStyle = getNaturalColor(this.colorHue, this.life * 0.8);
                    ctx.beginPath();
                    // Draw a "petal" or brush dab instead of a circle
                    ctx.ellipse(px, py, p.size, p.size * 0.4, p.angle, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        // 2. SILK RIBBON TRACER (Lissajous)
        class LissajousTracer extends Entity {
            constructor(x, y) {
                super(x, y);
                this.a = 1 + Math.floor(Math.random() * 4);
                this.b = 1 + Math.floor(Math.random() * 4);
                this.delta = Math.random() * Math.PI;
                this.scale = 60 + Math.random() * 80;
                this.history = [];
                this.rotation = 0;
                this.rotSpeed = (Math.random() - 0.5) * 0.05;
                // Multiple strands for a brush effect
                this.strands = Array(5).fill(0).map((_, i) => (i - 2) * 4); 
            }

            draw(ctx) {
                const time = (1.0 - this.life) * 8; 
                
                let lx = Math.sin(this.a * time + this.delta) * this.scale;
                let ly = Math.sin(this.b * time) * this.scale;

                this.rotation += this.rotSpeed;
                let rx = lx * Math.cos(this.rotation) - ly * Math.sin(this.rotation);
                let ry = lx * Math.sin(this.rotation) + ly * Math.cos(this.rotation);

                const currentPoint = {x: this.x + rx, y: this.y + ry};
                this.history.push(currentPoint);
                if(this.history.length > 40) this.history.shift();

                if (this.history.length < 2) return;

                // Draw strands
                ctx.globalAlpha = this.life;
                this.strands.forEach((offset, index) => {
                    ctx.strokeStyle = getNaturalColor(this.colorHue + (index * 5), this.life * 0.5);
                    ctx.lineWidth = 2 + Math.sin(time * 2); // Varying width
                    ctx.beginPath();
                    
                    for(let i=0; i<this.history.length - 1; i++) {
                        // Perpendicular offset logic could go here, but simple x/y offset works for abstract
                        const p1 = this.history[i];
                        const p2 = this.history[i+1];
                        
                        // Add some noise/organic jitter to the offset
                        const jitter = Math.sin(i * 0.5) * 2;
                        
                        if(i===0) ctx.moveTo(p1.x + offset + jitter, p1.y + offset + jitter);
                        // Smooth curves
                        const xc = (p1.x + p2.x) / 2 + offset + jitter;
                        const yc = (p1.y + p2.y) / 2 + offset + jitter;
                        ctx.quadraticCurveTo(p1.x + offset + jitter, p1.y + offset + jitter, xc, yc);
                    }
                    ctx.stroke();
                });
                ctx.globalAlpha = 1.0;
            }
        }

        // 3. ABSTRACT BLOOMS (Geometric Expansion)
        class PolyBurst extends Entity {
            constructor(x, y) {
                super(x, y);
                this.sides = 3 + Math.floor(Math.random() * 5);
                this.rotation = Math.random() * Math.PI;
                this.spin = (Math.random() - 0.5) * 0.1;
                this.layerCount = 4 + Math.floor(Math.random() * 3);
                this.noiseOffset = Math.random() * 100;
            }

            draw(ctx) {
                const maxRadius = 180;
                const currentRadius = (1.0 - this.life) * maxRadius;
                this.rotation += this.spin;

                // Fill with gradient for volume
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, currentRadius);
                gradient.addColorStop(0, getNaturalColor(this.colorHue, 0));
                gradient.addColorStop(1, getNaturalColor(this.colorHue, this.life * 0.2));

                ctx.fillStyle = gradient;
                ctx.strokeStyle = getNaturalColor(this.colorHue, this.life * 0.6);
                ctx.lineWidth = 1;

                for(let l=0; l<this.layerCount; l++) {
                    let r = currentRadius * (1 - l*0.15); 
                    if(r < 0) continue;

                    ctx.beginPath();
                    for(let i=0; i<=this.sides; i++) {
                        let angle = this.rotation + (i * 2 * Math.PI / this.sides) + (l * 0.1);
                        
                        // Add "wobble" for organic feel
                        let wobble = Math.sin(angle * 5 + this.noiseOffset) * 5;
                        
                        let px = this.x + (r + wobble) * Math.cos(angle);
                        let py = this.y + (r + wobble) * Math.sin(angle);
                        
                        if (i === 0) ctx.moveTo(px, py);
                        else ctx.lineTo(px, py);
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
            }
        }

        // 4. ORGANIC CONSTELLATION (Network)
        class NodeNetwork extends Entity {
            constructor(x, y) {
                super(x, y);
                this.nodes = [];
                for(let i=0; i<6; i++) {
                    this.nodes.push({
                        vx: (Math.random() - 0.5) * 3,
                        vy: (Math.random() - 0.5) * 3,
                        ox: 0, 
                        oy: 0,
                        size: 2 + Math.random() * 4
                    });
                }
            }

            draw(ctx) {
                // Soft glow nodes
                const nodesPos = this.nodes.map(n => {
                    n.ox += n.vx;
                    n.oy += n.vy;
                    return { x: this.x + n.ox, y: this.y + n.oy, size: n.size };
                });

                ctx.strokeStyle = getNaturalColor(this.colorHue, this.life * 0.3);
                ctx.lineWidth = 1;

                // Curved organic connections
                ctx.beginPath();
                for(let i=0; i<nodesPos.length; i++) {
                    for(let j=i+1; j<nodesPos.length; j++) {
                        const p1 = nodesPos[i];
                        const p2 = nodesPos[j];
                        
                        // Control point for curve (pulls towards center)
                        const cx = (p1.x + p2.x) / 2 + (this.x - (p1.x + p2.x)/2) * 0.2;
                        const cy = (p1.y + p2.y) / 2 + (this.y - (p1.y + p2.y)/2) * 0.2;

                        ctx.moveTo(p1.x, p1.y);
                        ctx.quadraticCurveTo(cx, cy, p2.x, p2.y);
                    }
                }
                ctx.stroke();

                // Draw Nodes as soft dots
                nodesPos.forEach(p => {
                    ctx.fillStyle = getNaturalColor(this.colorHue + 20, this.life);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                    ctx.fill();
                    
                    // Glow ring
                    ctx.strokeStyle = getNaturalColor(this.colorHue, this.life * 0.5);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * 1.5, 0, Math.PI*2);
                    ctx.stroke();
                });
            }
        }

        // --- CORE LOOP ---

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
        }

        function createRandomEffect(x, y) {
            initAudio();
            playSound();
            
            // Randomly choose an effect type
            const rand = Math.random();
            let effect;
            
            if(rand < 0.25) effect = new SpiralBurst(x, y);
            else if(rand < 0.50) effect = new LissajousTracer(x, y);
            else if(rand < 0.75) effect = new PolyBurst(x, y);
            else effect = new NodeNetwork(x, y);

            entities.push(effect);
            hueCycle += 20; // Shift global color
        }

        function animate() {
            // "Wet Paint" Trail effect
            // We use a lower alpha to let the previous frames show through longer, creating trails
            ctx.fillStyle = 'rgba(5, 5, 5, 0.15)'; 
            ctx.fillRect(0, 0, width, height);

            // Use 'screen' for additive color blending that doesn't blow out to white as fast as 'lighter'
            // or 'source-over' for a more paint-like layering. 
            // 'lighter' gives that neon look, let's try 'screen' for softer light.
            ctx.globalCompositeOperation = 'screen';

            for (let i = entities.length - 1; i >= 0; i--) {
                const ent = entities[i];
                if (ent.update()) {
                    ent.draw(ctx);
                } else {
                    entities.splice(i, 1);
                }
            }

            ctx.globalCompositeOperation = 'source-over';

            requestAnimationFrame(animate);
        }

        // --- INTERACTION ---

        window.addEventListener('resize', resize);
        
        // Mouse / Touch Handlers
        function handleInput(e) {
            e.preventDefault();
            if(hint) hint.style.opacity = '0'; // Hide hint after first interaction
            
            let clientX, clientY;
            
            if(e.changedTouches) {
                // Multi-touch support
                for(let i=0; i<e.changedTouches.length; i++) {
                    createRandomEffect(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                }
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
                createRandomEffect(clientX, clientY);
            }
        }

        window.addEventListener('mousedown', handleInput);
        window.addEventListener('touchstart', handleInput, {passive: false});

        // Init
        resize();
        animate();

    </script>
</body>
</html>